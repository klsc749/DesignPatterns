# 代理模式
代理模式(Proxy)，顾名思义，有代表打理的意思。某些情况下，当客户端不能或不适合直接访问目标业务对象时，业务对象可以通过代理把自己的业务托管起来，使客户端间接地通过代理进行业务访问。如此不但能方便用户使用，还能对客户端的访问进行一定的控制。

在本例中，我们创建的武器类具有开火功能。我们采用代理模式为武器类增加了弹药数量的限制，使得当弹药不足时，武器无法开火。
## 代理模式与装饰器模式的区别
虽然二者的理念与实现有点类似，但装饰器模式往往更加关注为其他对象增加功能，让客户端更加灵活地进行组件搭配；而代理模式更强调的则是一种对访问的管控，甚至是将被代理对象完全封装而隐藏起来，使其对客户端完全透明。

## 动态代理模式
 “动态代理”指例化过程是动态完成的，也就是说我们不需要专门针对某个接口去编写代码实现一个代理类，而是在接口运行时动态生成。我们通过实现 InvocationHandler 接口来自定义一个调用处理器，然后通过 Proxy 类的 newProxyInstance() 静态方法来创建一个代理对象。这个方法需要三个参数，第一个参数是类加载器，第二个参数是一个接口数组，表示这个代理对象实现了哪些接口，第三个参数是调用处理器对象。当我们通过代理对象调用一个接口中的方法时，这个方法的调用就会被转发到 InvocationHandler 接口的 invoke() 方法来调用。

 在本例中，我们通过动态代理模式为Enemy类增加了攻击具有冷却时间的限制。在实现过程中，我们通过代理类的构造函数将被代理对象传入，然后在代理类的 invoke() 方法中，通过反射调用被代理对象的方法，同时在方法调用前后加入了冷却时间的控制。